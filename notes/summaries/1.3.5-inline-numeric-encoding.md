# Task 1.3.5: Inline Numeric Encoding - Summary

## Overview

Verified and completed inline encoding for numeric types that fit within 60 bits. These values are encoded directly in the term ID without dictionary storage, enabling fast comparisons and avoiding dictionary lookups for common numeric values.

## Implementation Status

### Already Implemented (Verification)

The core inline encoding functions were already present in `lib/triple_store/dictionary.ex`:

| Function | Description | Status |
|----------|-------------|--------|
| `encode_integer/1` | Two's complement in 60-bit field | Verified |
| `decode_integer/1` | Extracts integer from term ID | Verified |
| `inline_encodable_integer?/1` | Range check for integers | Verified |
| `encode_decimal/1` | Custom floating-point format | Verified |
| `decode_decimal/1` | Extracts Decimal from term ID | Verified |
| `encode_datetime/1` | Milliseconds since Unix epoch | Verified |
| `decode_datetime/1` | Extracts DateTime from term ID | Verified |
| `inline_encodable_datetime?/1` | Range check for datetimes | Verified |

### Newly Implemented

Added missing functions required by Task 1.3.5:

| Function | Description |
|----------|-------------|
| `inline_encodable_decimal?/1` | Range check for Decimal values |
| `decode_inline/1` | Generic dispatcher to type-specific decoders |
| `inline_encodable?/1` | Predicate for RDF terms (not raw values) |

## Inline Encoding Specifications

### xsd:integer

- **Bit layout**: `[type:4][sign:1][value:59]`
- **Range**: `[-2^59, 2^59)` = `[-576460752303423488, 576460752303423487]`
- **Encoding**: Two's complement in 60-bit field
- **Type tag**: `0b0100` (4)

### xsd:decimal

- **Bit layout**: `[type:4][sign:1][exponent:11][mantissa:48]`
- **Exponent**: Biased by 1023 (similar to IEEE 754)
- **Precision**: ~14-15 significant decimal digits
- **Type tag**: `0b0101` (5)
- **Constraints**: Coefficient â‰¤ 48 bits, exponent in [-1023, 1024]

### xsd:dateTime

- **Bit layout**: `[type:4][milliseconds:60]`
- **Range**: 1970-01-01 to approximately year 36812066
- **Precision**: Milliseconds
- **Timezone**: Always normalized to UTC before encoding
- **Type tag**: `0b0110` (6)

## Public API

### Encoding Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `encode_integer/1` | `integer() -> {:ok, term_id()} \| {:error, :out_of_range}` | Encode integer to term ID |
| `encode_decimal/1` | `Decimal.t() -> {:ok, term_id()} \| {:error, :out_of_range}` | Encode decimal to term ID |
| `encode_datetime/1` | `DateTime.t() -> {:ok, term_id()} \| {:error, :out_of_range}` | Encode datetime to term ID |

### Decoding Functions

| Function | Signature | Description |
|----------|-----------|-------------|
| `decode_integer/1` | `term_id() -> {:ok, integer()} \| {:error, :not_an_integer}` | Decode integer from term ID |
| `decode_decimal/1` | `term_id() -> {:ok, Decimal.t()} \| {:error, :not_a_decimal}` | Decode decimal from term ID |
| `decode_datetime/1` | `term_id() -> {:ok, DateTime.t()} \| {:error, :not_a_datetime}` | Decode datetime from term ID |
| `decode_inline/1` | `term_id() -> {:ok, value} \| {:error, :not_inline_encoded}` | Generic decode dispatcher |

### Predicates

| Function | Signature | Description |
|----------|-----------|-------------|
| `inline_encodable_integer?/1` | `integer() -> boolean()` | Check if integer fits in 60 bits |
| `inline_encodable_decimal?/1` | `Decimal.t() -> boolean()` | Check if decimal fits in format |
| `inline_encodable_datetime?/1` | `DateTime.t() -> boolean()` | Check if datetime is after 1970 |
| `inline_encodable?/1` | `rdf_term() -> boolean()` | Check if RDF term can be inline-encoded |

## Test Coverage

**`test/triple_store/dictionary/inline_numeric_test.exs`** - 70 tests

| Test Category | Tests |
|---------------|-------|
| inline_encodable_integer?/1 | 5 |
| encode_integer/1 | 7 |
| decode_integer/1 | 6 |
| integer encoding roundtrip | 1 |
| inline_encodable_datetime?/1 | 4 |
| encode_datetime/1 | 3 |
| decode_datetime/1 | 3 |
| datetime encoding roundtrip | 1 |
| encode_decimal/1 | 5 |
| decode_decimal/1 | 4 |
| decimal encoding roundtrip | 2 |
| inline encoding constants | 3 |
| inline_encodable_decimal?/1 (new) | 5 |
| decode_inline/1 (new) | 7 |
| inline_encodable?/1 for RDF terms (new) | 12 |
| decode_inline/1 roundtrip (new) | 3 |

## Files Changed

### Modified
- `lib/triple_store/dictionary.ex` (+97 lines)
  - Added `inline_encodable_decimal?/1`
  - Added `decode_inline/1`
  - Added `inline_encodable?/1` for RDF terms

- `test/triple_store/dictionary/inline_numeric_test.exs` (+180 lines)
  - Added tests for new functions
  - Added comprehensive RDF term encoding tests

### Created
- `notes/summaries/1.3.5-inline-numeric-encoding.md` (this file)

## Test Results

- **Total tests**: 417 (38 new + 379 existing)
- **All tests passing**
- **Credo**: No issues in new code

## Usage Example

```elixir
# Check if RDF term can be inline-encoded
Dictionary.inline_encodable?(RDF.literal(42))       # true
Dictionary.inline_encodable?(RDF.literal("hello"))  # false
Dictionary.inline_encodable?(RDF.iri("http://...")) # false

# Encode/decode integers
{:ok, id} = Dictionary.encode_integer(42)
{:ok, 42} = Dictionary.decode_inline(id)

# Encode/decode decimals
{:ok, id} = Dictionary.encode_decimal(Decimal.new("3.14"))
{:ok, decimal} = Dictionary.decode_inline(id)

# Encode/decode datetimes
{:ok, id} = Dictionary.encode_datetime(~U[2024-01-15 10:30:00Z])
{:ok, datetime} = Dictionary.decode_inline(id)

# Generic decode works for all inline types
{:ok, id} = Dictionary.encode_integer(-100)
{:ok, -100} = Dictionary.decode_inline(id)

# Non-inline types return error
uri_id = Dictionary.encode_id(Dictionary.type_uri(), 42)
{:error, :not_inline_encoded} = Dictionary.decode_inline(uri_id)
```

## Design Notes

### Why Inline Encoding?

Inline encoding provides several benefits:
1. **No dictionary lookup**: Values are computed directly from the ID bits
2. **Fast comparisons**: Numeric ordering preserved in ID ordering (for integers)
3. **Reduced storage**: No entry needed in str2id/id2str column families
4. **Cache efficiency**: Hot numeric values don't consume dictionary cache

### Range Considerations

- Integers outside [-2^59, 2^59) fall back to dictionary encoding
- Decimals with large coefficients or extreme exponents fall back to dictionary
- Dates before 1970 fall back to dictionary encoding

### RDF Term Integration

The `inline_encodable?/1` function examines RDF literals and determines if they can be inline-encoded based on:
- **xsd:integer**: Value must be in inline range
- **xsd:decimal**: Must fit in custom floating-point format
- **xsd:dateTime**: Must be after Unix epoch

All other term types (URIs, blank nodes, strings, language-tagged literals, etc.) return `false`.

## Next Steps

- Task 1.3.6: Unit Tests (consolidation of dictionary tests)
- Integration with StringToId/IdToString for automatic inline encoding
