# Task 1.4.4: Pattern Matching - Summary

## Overview

Implemented pattern-to-index mapping for all 8 possible triple patterns. Each pattern selects the optimal index and constructs the appropriate prefix for efficient iteration.

## Implementation

### Core Functions

| Function | Description |
|----------|-------------|
| `select_index/1` | Selects optimal index and builds prefix for a pattern |
| `triple_matches_pattern?/2` | Checks if a triple matches a pattern (for filtering) |
| `pattern_shape/1` | Returns the binding shape of a pattern |

### Pattern to Index Mapping

| Pattern | Index | Prefix Size | Notes |
|---------|-------|-------------|-------|
| `{:bound, :bound, :bound}` | SPO | 24 bytes | Exact lookup |
| `{:bound, :bound, :var}` | SPO | 16 bytes | S-P prefix |
| `{:bound, :var, :var}` | SPO | 8 bytes | S prefix |
| `{:var, :bound, :bound}` | POS | 16 bytes | P-O prefix |
| `{:var, :bound, :var}` | POS | 8 bytes | P prefix |
| `{:var, :var, :bound}` | OSP | 8 bytes | O prefix |
| `{:bound, :var, :bound}` | OSP | 16 bytes | O-S prefix + filter |
| `{:var, :var, :var}` | SPO | 0 bytes | Full scan |

### Types Added

```elixir
@type bound_element :: {:bound, term_id()}
@type var_element :: :var
@type pattern_element :: bound_element() | var_element()
@type pattern :: {pattern_element(), pattern_element(), pattern_element()}

@type index_selection :: %{
  index: :spo | :pos | :osp,
  prefix: binary(),
  needs_filter: boolean(),
  filter_position: nil | :predicate
}
```

### API

```elixir
alias TripleStore.Index

# Select optimal index for a pattern
result = Index.select_index({{:bound, 1}, :var, {:bound, 3}})
# => %{index: :osp, prefix: <<...>>, needs_filter: true, filter_position: :predicate}

# Check if triple matches pattern
Index.triple_matches_pattern?({1, 2, 3}, {{:bound, 1}, :var, {:bound, 3}})
# => true

# Get pattern shape
Index.pattern_shape({{:bound, 1}, :var, {:bound, 3}})
# => {:bound, :var, :bound}
```

## Design Decisions

### Index Selection Strategy

The optimal index is chosen based on which positions are bound:
- **SPO**: Best when subject is bound (or for full scans)
- **POS**: Best when predicate is bound but subject is not
- **OSP**: Best when object is bound but neither subject nor predicate is

### S?O Pattern Handling

The `{:bound, :var, :bound}` pattern is special because no single index can efficiently answer it with just a prefix scan. We use:
1. OSP index with O-S prefix (filters to matching object + subject)
2. Post-filtering on predicate position

This approach minimizes I/O by leveraging the 16-byte prefix while accepting the need for filtering.

### Pattern Representation

Patterns use `{:bound, id}` for bound values and `:var` for unbound positions. This explicit representation:
- Distinguishes between "bound to 0" and "unbound"
- Enables pattern matching in function heads
- Makes the API self-documenting

## Test Coverage

**`test/triple_store/index/pattern_matching_test.exs`** - 42 tests

| Test Category | Tests |
|---------------|-------|
| Index selection | 8 |
| Prefix construction | 8 |
| Filter flags | 8 |
| triple_matches_pattern?/2 | 7 |
| pattern_shape/1 | 4 |
| Edge cases | 5 |
| Complete pattern coverage | 2 |

## Files Changed

### Modified
- `lib/triple_store/index.ex` - Added types and pattern matching functions (~180 lines)

### Created
- `test/triple_store/index/pattern_matching_test.exs` - Unit tests (42 tests)
- `notes/summaries/1.4.4-pattern-matching.md` - This summary

## Test Results

- **Total tests**: 571 (42 new + 529 existing)
- **All tests passing**
- **No new Credo issues**

## Next Steps

- Task 1.4.5: Index Lookup (return stream of matching triples)
- Task 1.4.6: Unit Tests (integration tests)
