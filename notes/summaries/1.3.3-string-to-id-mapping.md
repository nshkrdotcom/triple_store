# Task 1.3.3: String-to-ID Mapping Implementation - Summary

## Overview

Implemented the forward mapping from RDF term strings to 64-bit IDs using the `str2id` column family in RocksDB. This includes term encoding, lookup operations, and atomic get-or-create semantics with proper concurrency handling.

## Implementation

### Core Modules

**`lib/triple_store/dictionary/string_to_id.ex`**

Provides term encoding and read-only lookup operations:
- `encode_term/1` - Serializes RDF terms to binary keys
- `lookup_id/2` - Looks up existing term ID (direct RocksDB call)
- `lookup_ids/2` - Batch lookup for multiple terms

**`lib/triple_store/dictionary/manager.ex`**

GenServer that serializes write operations for atomic create-if-not-exists:
- `get_or_create_id/2` - Atomically gets or creates term ID
- `get_or_create_ids/2` - Batch version for bulk loading
- Internally manages SequenceCounter for ID generation

### Term Encoding Format

Terms are serialized with type prefixes to prevent collisions:

| Term Type | Encoding Format |
|-----------|-----------------|
| URI | `<<1, uri_string::binary>>` |
| BNode | `<<2, bnode_id::binary>>` |
| Plain Literal | `<<3, 0, value::binary>>` |
| Typed Literal | `<<3, 1, datatype_uri::binary, 0, value::binary>>` |
| Lang Literal | `<<3, 2, lang_tag::binary, 0, value::binary>>` |

### Key Features

1. **Term Normalization**
   - URIs: Angle brackets stripped, NFC Unicode normalized
   - Language tags: Lowercased for case-insensitive matching
   - All terms: NFC Unicode normalization for consistent keys

2. **Validation**
   - Max term size: 16KB
   - Null bytes rejected in URIs
   - UTF-8 validation

3. **Concurrency Model**
   - `lookup_id/2`: Direct NIF call (no serialization, max performance)
   - `Manager.get_or_create_id/2`: GenServer serialization ensures atomic create-if-not-exists

4. **Bidirectional Mapping**
   - `str2id`: term_key → 64-bit ID
   - `id2str`: 64-bit ID → term_key (stored automatically)

### Public API

**StringToId (read operations)**
| Function | Description |
|----------|-------------|
| `encode_term/1` | Serialize RDF term to binary key |
| `lookup_id/2` | Look up term's ID (returns `:not_found` if missing) |
| `lookup_ids/2` | Batch lookup for multiple terms |

**Manager (write operations)**
| Function | Description |
|----------|-------------|
| `start_link/1` | Start manager with `:db` option |
| `get_or_create_id/2` | Atomic get-or-create for single term |
| `get_or_create_ids/2` | Batch atomic get-or-create |
| `stop/1` | Stop manager (flushes sequence counter) |

## Test Coverage

**`test/triple_store/dictionary/string_to_id_test.exs`** - 42 tests

| Test Category | Tests |
|---------------|-------|
| encode_term for URIs | 5 |
| encode_term for BNodes | 2 |
| encode_term for Literals | 9 |
| encode_term edge cases | 2 |
| lookup_id | 5 |
| get_or_create_id | 7 |
| lookup_ids batch | 2 |
| get_or_create_ids batch | 3 |
| concurrent access | 3 |
| edge cases | 4 |

Key test scenarios:
- URI encoding with special characters and Unicode
- Literal encoding with datatypes and language tags
- Language tag case normalization (EN → en)
- Unicode NFC normalization (café composed vs decomposed)
- Concurrent get_or_create returning same ID
- Large batch operations (100 concurrent tasks)

## Files Changed

### Created
- `lib/triple_store/dictionary/string_to_id.ex` (~280 lines)
- `lib/triple_store/dictionary/manager.ex` (~210 lines)
- `test/triple_store/dictionary/string_to_id_test.exs` (~475 lines)
- `notes/summaries/1.3.3-string-to-id-mapping.md` (this file)

## Test Results

- **Total tests**: 351 (42 new + 309 existing)
- **All tests passing**
- **Credo**: No refactoring issues (1 software design suggestion in tests)

## Usage Example

```elixir
# Start manager with database reference
{:ok, manager} = Manager.start_link(db: db_ref)

# Atomic get-or-create (serialized for safety)
{:ok, id1} = Manager.get_or_create_id(manager, RDF.iri("http://example.org"))
{:ok, id2} = Manager.get_or_create_id(manager, RDF.iri("http://example.org"))
id1 == id2  # true - same ID returned

# Fast read-only lookup (direct to RocksDB)
{:ok, id} = StringToId.lookup_id(db, RDF.iri("http://example.org"))
:not_found = StringToId.lookup_id(db, RDF.iri("http://unknown.org"))

# Batch operations
{:ok, ids} = Manager.get_or_create_ids(manager, [uri1, uri2, bnode1])
{:ok, results} = StringToId.lookup_ids(db, [uri1, uri2, unknown])
# results = [{:ok, id1}, {:ok, id2}, :not_found]

# Cleanup
Manager.stop(manager)
```

## Design Notes

### Why Separate Manager GenServer?

The initial design attempted to use double-check locking with SequenceCounter, but this doesn't work because:
1. Two processes can both see `:not_found`
2. Both get different sequence numbers
3. Both write different IDs for the same term

The Manager GenServer serializes the entire check-then-create operation, ensuring only one ID is ever created per term.

### Read vs Write Path Separation

- **Reads** (`lookup_id`): Go directly to RocksDB NIF for maximum throughput
- **Writes** (`get_or_create_id`): Serialized through Manager for correctness

This provides optimal performance for read-heavy workloads while maintaining correctness for writes.

## Next Steps

- Task 1.3.4: ID-to-String Mapping (reverse lookup via id2str column family)
- Task 1.3.5: Inline Numeric Encoding (already mostly implemented)
