# Task 1.4.1: Key Encoding - Summary

## Overview

Implemented key encoding functions for the Triple Index Layer. Each index (SPO, POS, OSP) uses 24-byte keys (3 x 64-bit IDs) in big-endian format for correct lexicographic ordering.

## Implementation

### Key Encoding Functions

| Function | Description | Key Format |
|----------|-------------|------------|
| `spo_key/3` | Subject-Predicate-Object key | `<<s::64-big, p::64-big, o::64-big>>` |
| `pos_key/3` | Predicate-Object-Subject key | `<<p::64-big, o::64-big, s::64-big>>` |
| `osp_key/3` | Object-Subject-Predicate key | `<<o::64-big, s::64-big, p::64-big>>` |

### Key Decoding Functions

| Function | Description | Returns |
|----------|-------------|---------|
| `decode_spo_key/1` | Decode SPO key | `{subject, predicate, object}` |
| `decode_pos_key/1` | Decode POS key | `{predicate, object, subject}` |
| `decode_osp_key/1` | Decode OSP key | `{object, subject, predicate}` |

### Prefix Functions (for pattern matching)

| Function | Description | Prefix Size |
|----------|-------------|-------------|
| `spo_prefix/1` | Match by subject | 8 bytes |
| `spo_prefix/2` | Match by subject + predicate | 16 bytes |
| `pos_prefix/1` | Match by predicate | 8 bytes |
| `pos_prefix/2` | Match by predicate + object | 16 bytes |
| `osp_prefix/1` | Match by object | 8 bytes |
| `osp_prefix/2` | Match by object + subject | 16 bytes |

### Utility Functions

| Function | Description |
|----------|-------------|
| `encode_triple_keys/3` | Generate all 3 index keys for a triple |
| `key_to_triple/2` | Convert any index key to canonical `{s, p, o}` |

## Key Design Decisions

### Big-Endian Encoding
Keys use big-endian byte order (`::64-big`) to ensure that lexicographic ordering of binary keys matches numeric ordering of IDs. This enables efficient prefix-based range scans.

### Empty Values
Index entries use the key itself to encode the complete triple. Values are empty since no additional data is needed beyond the key.

### Triple Redundancy
Each triple is stored three times (once per index). This trades storage space for query performance - any pattern can be answered with a single prefix scan.

## Public API

```elixir
alias TripleStore.Index

# Encode keys
spo_key = Index.spo_key(subject_id, predicate_id, object_id)
pos_key = Index.pos_key(predicate_id, object_id, subject_id)
osp_key = Index.osp_key(object_id, subject_id, predicate_id)

# Decode keys
{s, p, o} = Index.decode_spo_key(spo_key)
{p, o, s} = Index.decode_pos_key(pos_key)
{o, s, p} = Index.decode_osp_key(osp_key)

# Build prefixes for pattern matching
prefix = Index.spo_prefix(subject_id)           # Match all with subject
prefix = Index.spo_prefix(subject_id, pred_id)  # Match subject + predicate

# Utility functions
keys = Index.encode_triple_keys(s, p, o)  # [{:spo, key}, {:pos, key}, {:osp, key}]
{s, p, o} = Index.key_to_triple(:pos, pos_key)  # Canonical order
```

## Test Coverage

**`test/triple_store/index/key_encoding_test.exs`** - 48 tests

| Test Category | Tests |
|---------------|-------|
| spo_key/3 | 5 |
| decode_spo_key/1 | 5 |
| spo_prefix/1 | 3 |
| spo_prefix/2 | 3 |
| pos_key/3 | 3 |
| decode_pos_key/1 | 1 |
| pos_prefix/1 | 2 |
| pos_prefix/2 | 2 |
| osp_key/3 | 3 |
| decode_osp_key/1 | 1 |
| osp_prefix/1 | 2 |
| osp_prefix/2 | 2 |
| Lexicographic ordering | 5 |
| encode_triple_keys/3 | 4 |
| key_to_triple/2 | 4 |
| Edge cases | 3 |

## Files Changed

### Modified
- `lib/triple_store/index.ex` - Added key encoding/decoding functions (~400 lines)

### Created
- `test/triple_store/index/key_encoding_test.exs` - Unit tests (48 tests)
- `notes/summaries/1.4.1-key-encoding.md` - This summary

## Test Results

- **Total tests**: 477 (48 new + 429 existing)
- **All tests passing**
- **Credo**: No issues

## Next Steps

- Task 1.4.2: Triple Insert (atomic write to all indices)
- Task 1.4.3: Triple Delete
- Task 1.4.4: Pattern Matching (prefix iteration)
- Task 1.4.5: Index Lookup
- Task 1.4.6: Integration Tests
